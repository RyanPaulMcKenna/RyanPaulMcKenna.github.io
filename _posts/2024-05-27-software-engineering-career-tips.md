---
layout: post
title: Software Engineering Career Tips
cover-img: /assets/img/softeng.webp
thumbnail-img: /assets/img/softeng.webp
share-img: /assets/img/softeng.webp
tags: [career, software engineering, computer science]
author: Ryan McKenna
---

# Software Engineering Career

# Basic Skills
Here is a list of many of the key areas of knowledge a Software Engineer must bring together holistically to form a strong approach to engineering and an effective workflow to solve problems quickly.

1. Bring all your knowledge to every situation.
    0. Deep knowledge of at least 1 high-level language like python and 1 lower level language like c/c++.
    1. Algorithms and Data structures
    2. Mathematics
    3. Rember to profile code, perform code coverage, use complexity metric tools and generate documentation.
    4. Architecture and design knowledge
    5. Programming principles and guidelines
        1. Principles of Software Engineering: [https://www.d.umn.edu/~gshute/softeng/principles.html](https://www.d.umn.edu/~gshute/softeng/principles.html)
        2. SOLID
            - The [Single-responsibility principle](https://en.wikipedia.org/wiki/Single-responsibility_principle): There should never be more than one reason for a [class](https://en.wikipedia.org/wiki/Class_(computer_programming)) to change. In other words, every class should have only one responsibility.
            - The [Open–closed principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle): Software entities ... should be open for extension, but closed for modification.
            - The [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle): Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. See also [design by contract](https://en.wikipedia.org/wiki/Design_by_contract).
            - The [Interface segregation principle](https://en.wikipedia.org/wiki/Interface_segregation_principle): Clients should not be forced to depend upon interfaces that they do not use.
            - The [Dependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle): Depend upon abstractions, not concretes.
    6. [Refactoring](https://refactoring.guru/refactoring) 
        1. Once you understand what the code you are refactoring is trying to do you can write tests to drive the creation of the refactored code
        2. So that even the refactoring process is test-driven
    7. Test-driven development
    8. Behaviour driven development
    9. Gathering Requirements and creating use cases
        1. Discussions and meeting notes
        2. Lexical analysis: nouns, adjectives, verbs
        3. Use cases: actors, attributes, actions
        4. Touch base with client/stake holder to access correctness
        5. Build prototype very quickly that mimics the interface for the user and nothing else with dummy interactions
        6. Return to previous sections according to feedback or begin development for real.
2. For any area of software development see the roadmaps [https://roadmap.sh/](https://roadmap.sh/frontend)
    1. They can efficiently explain any area of the subjects, be it frontend, backend or otherwise.
    2. Roadmaps are a great reference and means of finding the right information fast.
        

## Machine Learning Specific

1. Understand the data and the problem. This will determine what type of model is best suited.
2. Clean, prepare and transform data as required.
3. Define model and hyper parameters (epochs, learning rate, batch-size, layer sizes ,  etc).
4. Define loss function, back propagation.
5. Iterate, evaluate how different variables weigh against variance in results.